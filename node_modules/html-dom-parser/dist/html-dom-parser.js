(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.HTMLDOMParser = factory());
}(this, (function () { 'use strict';

  /**
   * SVG elements are case-sensitive.
   *
   * @see {@link https://developer.mozilla.org/docs/Web/SVG/Element#SVG_elements_A_to_Z}
   */
  var CASE_SENSITIVE_TAG_NAMES = [
    'animateMotion',
    'animateTransform',
    'clipPath',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussainBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence',
    'foreignObject',
    'linearGradient',
    'radialGradient',
    'textPath'
  ];

  var constants = {
    CASE_SENSITIVE_TAG_NAMES: CASE_SENSITIVE_TAG_NAMES
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  var node = createCommonjsModule(function (module, exports) {
  var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneNode = exports.Element = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
  var nodeTypes = new Map([
      ["tag" /* Tag */, 1],
      ["script" /* Script */, 1],
      ["style" /* Style */, 1],
      ["directive" /* Directive */, 1],
      ["text" /* Text */, 3],
      ["cdata" /* CDATA */, 4],
      ["comment" /* Comment */, 8],
  ]);
  /**
   * This object will be used as the prototype for Nodes when creating a
   * DOM-Level-1-compliant structure.
   */
  var Node = /** @class */ (function () {
      /**
       *
       * @param type The type of the node.
       */
      function Node(type) {
          this.type = type;
          /** Parent of the node */
          this.parent = null;
          /** Previous sibling */
          this.prev = null;
          /** Next sibling */
          this.next = null;
          /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
          this.startIndex = null;
          /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
          this.endIndex = null;
      }
      Object.defineProperty(Node.prototype, "nodeType", {
          // Read-only aliases
          get: function () {
              var _a;
              return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Node.prototype, "parentNode", {
          // Read-write aliases for properties
          get: function () {
              return this.parent;
          },
          set: function (parent) {
              this.parent = parent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Node.prototype, "previousSibling", {
          get: function () {
              return this.prev;
          },
          set: function (prev) {
              this.prev = prev;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Node.prototype, "nextSibling", {
          get: function () {
              return this.next;
          },
          set: function (next) {
              this.next = next;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Clone this node, and optionally its children.
       *
       * @param recursive Clone child nodes as well.
       * @returns A clone of the node.
       */
      Node.prototype.cloneNode = function (recursive) {
          if (recursive === void 0) { recursive = false; }
          return cloneNode(this, recursive);
      };
      return Node;
  }());
  exports.Node = Node;
  var DataNode = /** @class */ (function (_super) {
      __extends(DataNode, _super);
      /**
       * @param type The type of the node
       * @param data The content of the data node
       */
      function DataNode(type, data) {
          var _this = _super.call(this, type) || this;
          _this.data = data;
          return _this;
      }
      Object.defineProperty(DataNode.prototype, "nodeValue", {
          get: function () {
              return this.data;
          },
          set: function (data) {
              this.data = data;
          },
          enumerable: false,
          configurable: true
      });
      return DataNode;
  }(Node));
  exports.DataNode = DataNode;
  var Text = /** @class */ (function (_super) {
      __extends(Text, _super);
      function Text(data) {
          return _super.call(this, "text" /* Text */, data) || this;
      }
      return Text;
  }(DataNode));
  exports.Text = Text;
  var Comment = /** @class */ (function (_super) {
      __extends(Comment, _super);
      function Comment(data) {
          return _super.call(this, "comment" /* Comment */, data) || this;
      }
      return Comment;
  }(DataNode));
  exports.Comment = Comment;
  var ProcessingInstruction = /** @class */ (function (_super) {
      __extends(ProcessingInstruction, _super);
      function ProcessingInstruction(name, data) {
          var _this = _super.call(this, "directive" /* Directive */, data) || this;
          _this.name = name;
          return _this;
      }
      return ProcessingInstruction;
  }(DataNode));
  exports.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = /** @class */ (function (_super) {
      __extends(NodeWithChildren, _super);
      /**
       *
       * @param type Type of the node.
       * @param children Children of the node. Only certain node types can have children.
       */
      function NodeWithChildren(type, children) {
          var _this = _super.call(this, type) || this;
          _this.children = children;
          return _this;
      }
      Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
          // Aliases
          get: function () {
              var _a;
              return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
          get: function () {
              return this.children.length > 0
                  ? this.children[this.children.length - 1]
                  : null;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
          get: function () {
              return this.children;
          },
          set: function (children) {
              this.children = children;
          },
          enumerable: false,
          configurable: true
      });
      return NodeWithChildren;
  }(Node));
  exports.NodeWithChildren = NodeWithChildren;
  var Element = /** @class */ (function (_super) {
      __extends(Element, _super);
      /**
       * @param name Name of the tag, eg. `div`, `span`.
       * @param attribs Object mapping attribute names to attribute values.
       * @param children Children of the node.
       */
      function Element(name, attribs, children) {
          if (children === void 0) { children = []; }
          var _this = _super.call(this, name === "script"
              ? "script" /* Script */
              : name === "style"
                  ? "style" /* Style */
                  : "tag" /* Tag */, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.attribs = attribs;
          return _this;
      }
      Object.defineProperty(Element.prototype, "tagName", {
          // DOM Level 1 aliases
          get: function () {
              return this.name;
          },
          set: function (name) {
              this.name = name;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Element.prototype, "attributes", {
          get: function () {
              var _this = this;
              return Object.keys(this.attribs).map(function (name) { return ({
                  name: name,
                  value: _this.attribs[name],
              }); });
          },
          enumerable: false,
          configurable: true
      });
      return Element;
  }(NodeWithChildren));
  exports.Element = Element;
  /**
   * Clone a node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  function cloneNode(node, recursive) {
      if (recursive === void 0) { recursive = false; }
      switch (node.type) {
          case "text" /* Text */:
              return new Text(node.data);
          case "directive" /* Directive */: {
              var instr = node;
              return new ProcessingInstruction(instr.name, instr.data);
          }
          case "comment" /* Comment */:
              return new Comment(node.data);
          case "tag" /* Tag */:
          case "script" /* Script */:
          case "style" /* Style */: {
              var elem = node;
              var children = recursive ? cloneChildren(elem.children) : [];
              var clone_1 = new Element(elem.name, __assign({}, elem.attribs), children);
              children.forEach(function (child) { return (child.parent = clone_1); });
              return clone_1;
          }
          case "cdata" /* CDATA */: {
              var cdata = node;
              var children = recursive ? cloneChildren(cdata.children) : [];
              var clone_2 = new NodeWithChildren("cdata" /* CDATA */, children);
              children.forEach(function (child) { return (child.parent = clone_2); });
              return clone_2;
          }
          case "doctype" /* Doctype */: {
              // This type isn't used yet.
              throw new Error("Not implemented yet: ElementType.Doctype case");
          }
      }
  }
  exports.cloneNode = cloneNode;
  function cloneChildren(childs) {
      var children = childs.map(function (child) { return cloneNode(child, true); });
      for (var i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
      }
      return children;
  }
  });

  var CASE_SENSITIVE_TAG_NAMES$1 = constants.CASE_SENSITIVE_TAG_NAMES;

  var Comment = node.Comment;
  var Element = node.Element;
  var ProcessingInstruction = node.ProcessingInstruction;
  var Text = node.Text;

  var caseSensitiveTagNamesMap = {};
  var tagName;

  for (var i = 0, len = CASE_SENSITIVE_TAG_NAMES$1.length; i < len; i++) {
    tagName = CASE_SENSITIVE_TAG_NAMES$1[i];
    caseSensitiveTagNamesMap[tagName.toLowerCase()] = tagName;
  }

  /**
   * Gets case-sensitive tag name.
   *
   * @param  {string}           tagName - Tag name in lowercase.
   * @return {string|undefined}         - Case-sensitive tag name.
   */
  function getCaseSensitiveTagName(tagName) {
    return caseSensitiveTagNamesMap[tagName];
  }

  /**
   * Formats DOM attributes to a hash map.
   *
   * @param  {NamedNodeMap} attributes - List of attributes.
   * @return {object}                  - Map of attribute name to value.
   */
  function formatAttributes(attributes) {
    var result = {};
    var attribute;
    // `NamedNodeMap` is array-like
    for (var i = 0, len = attributes.length; i < len; i++) {
      attribute = attributes[i];
      result[attribute.name] = attribute.value;
    }
    return result;
  }

  /**
   * Corrects the tag name if it is case-sensitive (SVG).
   * Otherwise, returns the lowercase tag name (HTML).
   *
   * @param  {string} tagName - Lowercase tag name.
   * @return {string}         - Formatted tag name.
   */
  function formatTagName(tagName) {
    tagName = tagName.toLowerCase();
    var caseSensitiveTagName = getCaseSensitiveTagName(tagName);
    if (caseSensitiveTagName) {
      return caseSensitiveTagName;
    }
    return tagName;
  }

  /**
   * Formats the browser DOM nodes to mimic the output of `htmlparser2.parseDOM()`.
   *
   * @param  {NodeList} nodes        - DOM nodes.
   * @param  {Element}  [parentNode] - Formatted parent node.
   * @param  {string}   [directive]  - Directive.
   * @return {Array<Comment|Element|ProcessingInstruction|Text>}
   */
  function formatDOM(domNodes, parentNode, directive) {
    parentNode = parentNode || null;

    var domNode;
    var node;
    var prevNode;
    var output = [];

    for (var i = 0, len = domNodes.length; i < len; i++) {
      domNode = domNodes[i];

      // set the node data given the type
      switch (domNode.nodeType) {
        case 1:
          // script, style, or tag
          node = new Element(
            formatTagName(domNode.nodeName),
            formatAttributes(domNode.attributes)
          );
          node.children = formatDOM(domNode.childNodes, node);
          break;

        case 3:
          node = new Text(domNode.nodeValue);
          break;

        case 8:
          node = new Comment(domNode.nodeValue);
          break;
      }

      // set next for previous node
      prevNode = output[i - 1] || null;
      if (prevNode) {
        prevNode.next = node;
      }

      // set properties for current node
      node.parent = parentNode;
      node.prev = prevNode;
      node.next = null;

      output.push(node);
    }

    if (directive) {
      node = new ProcessingInstruction(
        directive.substring(0, directive.indexOf(' ')).toLowerCase(),
        directive
      );
      node.next = output[0] || null;
      node.parent = parentNode;
      output.unshift(node);

      if (output[1]) {
        output[1].prev = output[0];
      }
    }

    return output;
  }

  /**
   * Detects if browser is Internet Explorer.
   *
   * @param  {number}  [version] - IE version to detect.
   * @return {boolean}           - Whether IE or the version is detected.
   */
  function isIE(version) {
    if (version) {
      return document.documentMode === version;
    }
    return /(MSIE |Trident\/|Edge\/)/.test(navigator.userAgent);
  }

  var utilities = {
    formatAttributes: formatAttributes,
    formatDOM: formatDOM,
    isIE: isIE
  };

  // constants
  var HTML = 'html';
  var HEAD = 'head';
  var BODY = 'body';
  var FIRST_TAG_REGEX = /<([a-zA-Z]+[0-9]?)/; // e.g., <h1>
  var HEAD_TAG_REGEX = /<head.*>/i;
  var BODY_TAG_REGEX = /<body.*>/i;
  // http://www.w3.org/TR/html/syntax.html#void-elements
  var VOID_ELEMENTS_REGEX = /<(area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)(.*?)\/?>/gi;

  // detect IE browser
  var isIE9 = utilities.isIE(9);
  var isIE$1 = isIE9 || utilities.isIE();

  // falls back to `parseFromString` if `createHTMLDocument` cannot be used
  var parseFromDocument = function () {
    throw new Error(
      'This browser does not support `document.implementation.createHTMLDocument`'
    );
  };

  var parseFromString = function () {
    throw new Error(
      'This browser does not support `DOMParser.prototype.parseFromString`'
    );
  };

  /**
   * DOMParser (performance: slow).
   *
   * @see https://developer.mozilla.org/docs/Web/API/DOMParser#Parsing_an_SVG_or_HTML_document
   */
  if (typeof window.DOMParser === 'function') {
    var domParser = new window.DOMParser();

    // IE9 does not support 'text/html' MIME type
    // https://msdn.microsoft.com/en-us/library/ff975278(v=vs.85).aspx
    var mimeType = isIE9 ? 'text/xml' : 'text/html';

    /**
     * Creates an HTML document using `DOMParser.parseFromString`.
     *
     * @param  {string} html      - The HTML string.
     * @param  {string} [tagName] - The element to render the HTML (with 'body' as fallback).
     * @return {HTMLDocument}
     */
    parseFromString = function (html, tagName) {
      if (tagName) {
        html = '<' + tagName + '>' + html + '</' + tagName + '>';
      }

      // because IE9 only supports MIME type 'text/xml', void elements need to be self-closed
      if (isIE9) {
        html = html.replace(VOID_ELEMENTS_REGEX, '<$1$2$3/>');
      }

      return domParser.parseFromString(html, mimeType);
    };

    parseFromDocument = parseFromString;
  }

  /**
   * DOMImplementation (performance: fair).
   *
   * @see https://developer.mozilla.org/docs/Web/API/DOMImplementation/createHTMLDocument
   */
  if (document.implementation) {
    // title parameter is required in IE
    // https://msdn.microsoft.com/en-us/library/ff975457(v=vs.85).aspx
    var doc = document.implementation.createHTMLDocument(
      isIE$1 ? 'html-dom-parser' : undefined
    );

    /**
     * Use HTML document created by `document.implementation.createHTMLDocument`.
     *
     * @param  {string} html      - The HTML string.
     * @param  {string} [tagName] - The element to render the HTML (with 'body' as fallback).
     * @return {HTMLDocument}
     */
    parseFromDocument = function (html, tagName) {
      if (tagName) {
        doc.documentElement.getElementsByTagName(tagName)[0].innerHTML = html;
        return doc;
      }

      try {
        doc.documentElement.innerHTML = html;
        return doc;
        // fallback when certain elements in `documentElement` are read-only (IE9)
      } catch (err) {
        if (parseFromString) {
          return parseFromString(html);
        }
      }
    };
  }

  /**
   * Template (performance: fast).
   *
   * @see https://developer.mozilla.org/docs/Web/HTML/Element/template
   */
  var template = document.createElement('template');
  var parseFromTemplate;

  if (template.content) {
    /**
     * Uses a template element (content fragment) to parse HTML.
     *
     * @param  {string} html - The HTML string.
     * @return {NodeList}
     */
    parseFromTemplate = function (html) {
      template.innerHTML = html;
      return template.content.childNodes;
    };
  }

  /**
   * Parses HTML string to DOM nodes.
   *
   * @param  {string}   html - HTML markup.
   * @return {NodeList}
   */
  function domparser(html) {
    var firstTagName;
    var match = html.match(FIRST_TAG_REGEX);

    if (match && match[1]) {
      firstTagName = match[1].toLowerCase();
    }

    var doc;
    var element;
    var elements;

    switch (firstTagName) {
      case HTML:
        doc = parseFromString(html);

        // the created document may come with filler head/body elements,
        // so make sure to remove them if they don't actually exist
        if (!HEAD_TAG_REGEX.test(html)) {
          element = doc.getElementsByTagName(HEAD)[0];
          if (element) {
            element.parentNode.removeChild(element);
          }
        }

        if (!BODY_TAG_REGEX.test(html)) {
          element = doc.getElementsByTagName(BODY)[0];
          if (element) {
            element.parentNode.removeChild(element);
          }
        }

        return doc.getElementsByTagName(HTML);

      case HEAD:
      case BODY:
        elements = parseFromDocument(html).getElementsByTagName(firstTagName);

        // if there's a sibling element, then return both elements
        if (BODY_TAG_REGEX.test(html) && HEAD_TAG_REGEX.test(html)) {
          return elements[0].parentNode.childNodes;
        }
        return elements;

      // low-level tag or text
      default:
        if (parseFromTemplate) {
          return parseFromTemplate(html);
        }

        return parseFromDocument(html, BODY).getElementsByTagName(BODY)[0]
          .childNodes;
    }
  }

  var domparser_1 = domparser;

  var formatDOM$1 = utilities.formatDOM;
  var isIE9$1 = utilities.isIE(9);

  var DIRECTIVE_REGEX = /<(![a-zA-Z\s]+)>/; // e.g., <!doctype html>

  /**
   * Parses HTML string to DOM nodes in browser.
   *
   * @param  {String} html  - HTML markup.
   * @return {DomElement[]} - DOM elements.
   */
  function HTMLDOMParser(html) {
    if (typeof html !== 'string') {
      throw new TypeError('First argument must be a string');
    }

    if (!html) {
      return [];
    }

    // match directive
    var match = html.match(DIRECTIVE_REGEX);
    var directive;

    if (match && match[1]) {
      directive = match[1];

      // remove directive in IE9 because DOMParser uses
      // MIME type 'text/xml' instead of 'text/html'
      if (isIE9$1) {
        html = html.replace(match[0], '');
      }
    }

    return formatDOM$1(domparser_1(html), null, directive);
  }

  var htmlToDomClient = HTMLDOMParser;

  return htmlToDomClient;

})));
//# sourceMappingURL=html-dom-parser.js.map
